<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Test matchmaking & rooms</title>
    <style>
        body{font-family:sans-serif;max-width:760px;margin:24px auto;padding:0 12px}
        #log{border:1px solid #999;height:180px;overflow:auto;padding:6px;border-radius:8px}
        input,button{padding:6px 10px;margin:4px}
    </style>
</head>
<body>
<h1>SignalR ‚Äì Matchmaking & Rooms par code</h1>

<div>
    <span>Login</span>
    <label>Email: <input id="loginEmail" value="john.doe@email.com" /></label>
    <label>Mot de passe: <input id="loginPassword" value="Password123"/></label>
    <button id="login">Login</button>
    <span id="loginStatus"></span>
</div>

<div>
    <span>Connexion GameHub</span>
    <label>Pseudo: <input id="name" value="Joueur" /></label>
    <button id="connect">Connexion</button>
    <span id="status"></span>
</div>

<hr/>

<h3>Mode 1 : Matchmaking al√©atoire</h3>
<div>
    <button id="queue" disabled>Se mettre en file</button>
    <button id="leaveQueue" disabled>Quitter la file / room</button>
</div>

<h3>Mode 2 : Room par code</h3>
<div>
    <input id="deckId" placeholder="Deck ID (GUID)" value="d3b07384-d9a1-4d3b-92d8-4f5c6e7a8b9c" style="width: 280px;" />
    <br/>
    <input id="roomCode" placeholder="CODE (ex: Q7D9K2)" />
    <button id="create">Cr√©er room</button>
    <button id="join">Rejoindre room</button>
    <button id="leaveCode">Quitter room (code)</button>
</div>

<div id="room" style="display:none;">
    <h2 id="roomTitle"></h2>
    <div id="phaseInfo" style="background:#f0f0f0;padding:10px;margin:10px 0;border-radius:8px;">
        <strong>√âtat de la partie:</strong>
        <span id="gameState">Non d√©marr√©e</span>
        <br/>
        <strong>Tour:</strong> <span id="turnNumber">-</span>
        <strong>Phase:</strong> <span id="currentPhase">-</span>
        <strong>Joueur actif:</strong> <span id="activePlayer">-</span>
    </div>
    <div>
        <button id="startGame">D√©marrer la partie</button>
        <button id="changePhase">Changer de phase</button>
    </div>
    <div id="log"></div>
    <input id="msg" placeholder="Message" />
    <button id="send">Envoyer</button>
    <br/>
    <label><span id="FirstArgumentLabel"></span><input id="FirstArgumentValue" type="number" value="1" min="1" style="width:50px"/></label>
    <label><span id="SecondArgumentLabel"></span><input id="SecondArgumentValue" type="number" value="1" min="1" style="width:50px"/></label>
    <button id="SendActionButton">Jouer Carte</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@8/dist/browser/signalr.min.js"></script>
<script>

    const loginEmail = document.getElementById("loginEmail");
    const loginPassword = document.getElementById("loginPassword")
    const loginStatus = document.getElementById("loginStatus");

    const status = document.getElementById('status');
    const roomDiv = document.getElementById('room');
    const roomTitle = document.getElementById('roomTitle');
    const log = document.getElementById('log');

    const btnConnect = document.getElementById('connect');
    const btnQueue = document.getElementById('queue');
    const btnLeaveQueue = document.getElementById('leaveQueue');
    const btnLogin = document.getElementById("login");

    const btnCreate = document.getElementById('create');
    const btnJoin   = document.getElementById('join');
    const btnLeaveCode = document.getElementById('leaveCode');

    const nameInput = document.getElementById('name');
    const codeInput = document.getElementById('roomCode');
    const deckInput = document.getElementById('deckId');
    const msgInput  = document.getElementById('msg');
    const btnSend   = document.getElementById('send');

    const btnSendAction   = document.getElementById('SendActionButton');
    const FirstArgumentValue = document.getElementById('FirstArgumentValue');
    const FirstArgumentLabel = document.getElementById("FirstArgumentLabel");
    const SecondArgumentValue = document.getElementById('SecondArgumentValue');
    const SecondArgumentLabel = document.getElementById("SecondArgumentLabel");

    // √âl√©ments de phase
    const btnStartGame = document.getElementById('startGame');
    const btnChangePhase = document.getElementById('changePhase');
    const gameStateSpan = document.getElementById('gameState');
    const turnNumberSpan = document.getElementById('turnNumber');
    const currentPhaseSpan = document.getElementById('currentPhase');
    const activePlayerSpan = document.getElementById('activePlayer');

    // Map des phases pour l'affichage
    const phaseNames = {
        0: 'Placement',
        1: 'Attack (Attaque)',
        2: 'Defense (D√©fense)',
        3: 'EndTurn (Fin de tour)'
    };

    let connection, currentKey = null, mode = null; // mode: 'queue' | 'code'
    let myPosition = null; // Position du joueur (1 ou 2)
    let myUserId = null; // Notre userId (GUID)
    let activePlayerId = null; // userId du joueur actif

    let jwtToken = "";

    function append(t){ const p=document.createElement('div'); p.textContent=t; log.appendChild(p); log.scrollTop=log.scrollHeight; }

    btnLogin.onclick = async () => {
        const response = await fetch("http://localhost:4000/api/auth/login", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            referrerPolicy: "strict-origin-when-cross-origin",
            body: JSON.stringify({
                    email: loginEmail.value,
                    password: loginPassword.value
            })
        })
        const result = await response.json();
        jwtToken = result.data.token;
        loginStatus.textContent = "Connect√©: " + jwtToken;
    }

    btnConnect.onclick = async () => {
        try {
            connection = await new signalR.HubConnectionBuilder()
                .withUrl("/hubs/game", {
                    accessTokenFactory: () => jwtToken
                })
                .withAutomaticReconnect()
                .build();

            connection.on("Connected", id => {
                status.textContent = "Connect√©: " + id;
                btnQueue.disabled = false;
                btnCreate.disabled = false;
                btnJoin.disabled = false;
                btnLeaveQueue.disabled = false;
                btnLeaveCode.disabled = false;
            });

            connection.on("Waiting", () => {
                status.textContent = "En attente d'un adversaire...";
            });

            connection.on("Matched", (key, payload) => {
                currentKey = key;
                myPosition = payload.position;
                roomTitle.textContent = `Salle ${key} (Position: ${payload.position})`;
                roomDiv.style.display = 'block';
                append(`Match vs ${payload.opponent}. Tu es le joueur ${payload.position}.`);
                // Pr√©-remplir la position pour DrawCards
                document.getElementById('drawPosition').value = payload.position;
            });

            connection.on("GameStarted", (result) => {
                gameStateSpan.textContent = "En cours";
                updatePhaseDisplay(result);
                append(`üéÆ Partie d√©marr√©e ! Tour ${result.turnNumber}, Phase: ${phaseNames[result.currentPhase]}`);
            });

            connection.on("PhaseChanged", (result) => {
                updatePhaseDisplay(result);
                let msg = `‚è© Phase chang√©e: Tour ${result.turnNumber}, Phase: ${phaseNames[result.currentPhase]}`;
                if (result.autoChanged) {
                    msg += ` (Auto: ${result.autoChangeReason})`;
                }
                append(msg);
                append(`Change phase result: ${JSON.stringify(result)}`);
            });

            connection.on("AutoDraw", (result) => {
                append(`üÉè Pioche automatique: ${JSON.stringify(result)}`);
            });

            connection.on("Error", (message) => {
                append(`‚ùå Erreur: ${message}`);
            });

            connection.on("RoomCreated", code => {
                mode = 'code';
                currentKey = code;
                codeInput.value = code;
                roomTitle.textContent = `Salle ${code}`;
                roomDiv.style.display = 'block';
                append(`Salle cr√©√©e. Partage le code: ${code}`);
            });

            connection.on("RoomCreateError", reason => {
                status.textContent = reason === "CODE_TAKEN" ? "Code d√©j√† pris." : "Erreur cr√©ation salle.";
            });

            connection.on("RoomJoinError", reason => {
                status.textContent = reason === "ROOM_FULL" ? "Salle pleine." : "Salle introuvable.";
            });

            connection.on("ReceiveRoomMessage", (key, from, text) => {
                append(`${from}: ${text}`);
            });

            connection.on("OpponentLeft", (key) => {
                append("Ô∏è L'adversaire a quitt√©.");
            });

            connection.on("CardsDrawn", (result) => {
                activePlayerId = result.playerId;
                append(`J'ai pioch√©: ${JSON.stringify(result)}`);
            });

            connection.on("OpponentCardsDrawn", (result) => {
                append(`L'adversaire a pioch√©: ${JSON.stringify(result)}`);
            });

            connection.on("PlayCardResult", (result) => {
                append(`Carte jou√©: ${JSON.stringify(result)}`);
            })

            connection.on("HandleAttackEngage", (result) => {
                append(`Nouvelle attaque: ${JSON.stringify(result)}`);
            })

            connection.on("HandleDefenseEngage", (result) => {
                append(`Nouvelle d√©fense: ${JSON.stringify(result)}`);
            })

            connection.on("OpponentPlayCardResult", (result) => {
                append(`L'adversiare √† jou√© une carte: ${JSON.stringify(result)}`);
            })

            await connection.start();
            await connection.invoke("SetName", nameInput.value || "Joueur");
            status.textContent = "Connect√© au hub.";
        } catch (e) {
            status.textContent = "Erreur de connexion (voir console).";
            console.error(e);
        }
    };

    const playCard = async () => {
        if (!currentKey) return;
        const position = parseInt(SecondArgumentValue.value) || 0;
        const id = parseInt(FirstArgumentValue.value) || 0;
        await connection.invoke("PlayCard", id, position);
        append(`Demande de jouer une carte: carte ${id} a la position ${position}`);
    };

    const attackCard = async () => {
        if (!currentKey) return;
        const cardId = parseInt(FirstArgumentValue.value);
        await connection.invoke("HandleAttackPos", cardId);
        append(`Demande de changer la position d'attaque de la carte ${cardId}`);
    }

    const defendCard = async () => {
        if (!currentKey) return;
        const cardId = parseInt(FirstArgumentValue.value);
        const opponentCardId = parseInt(SecondArgumentValue.value);
        await connection.invoke("HandleDefensePos", cardId, opponentCardId);
    }

    btnQueue.onclick = async () => {
        mode = 'queue';
        const deckId = (deckInput.value || "").trim();
        if (!deckId) return alert("Entre un Deck ID pour le matchmaking.");
        await connection.invoke("JoinQueue", deckId);
        status.textContent = "Demande de matchmaking envoy√©e...";
    };
    btnLeaveQueue.onclick = async () => {
        await connection.invoke("LeaveQueue");
        append("Vous avez quitt√© la file/room (matchmaking).");
        currentKey = null;
    };

    btnCreate.onclick = async () => {
        mode = 'code';
        const preferred = (codeInput.value || "").trim() || null;
        const deckId = (deckInput.value || "").trim();
        if (!deckId) return alert("Entre un Deck ID.");
        await connection.invoke("CreateRoom", deckId, preferred);
    };
    btnJoin.onclick = async () => {
        mode = 'code';
        const code = (codeInput.value || "").trim();
        const deckId = (deckInput.value || "").trim();
        if (!code) return alert("Entre un code.");
        if (!deckId) return alert("Entre un Deck ID.");
        await connection.invoke("JoinRoom", deckId, code);
    };
    btnLeaveCode.onclick = async () => {
        await connection.invoke("LeaveRoomByCode");
        append("Vous avez quitt√© la room (code).");
        currentKey = null;
    };

    btnSend.onclick = async () => {
        const t = msgInput.value.trim();
        if (!t || !currentKey) return;
        if (mode === 'code')
            await connection.invoke("SendRoomMessageByCode", currentKey, t);
        else
            await connection.invoke("SendRoomMessage", currentKey, t);
        append(`Moi: ${t}`);
        msgInput.value = "";
    };

    btnStartGame.onclick = async () => {
        if (!currentKey) return alert("Pas dans une salle.");
        await connection.invoke("StartGame");
        append("Demande de d√©marrage de la partie...");
    };

    btnChangePhase.onclick = async () => {
        if (!currentKey) return alert("Pas dans une salle.");
        await connection.invoke("ChangePhase");
        append("Demande de changement de phase...");
    };

    function updatePhaseDisplay(result) {
        turnNumberSpan.textContent = result.turnNumber;
        currentPhaseSpan.textContent = phaseNames[result.currentPhase] || result.currentPhase;
        
        // D√©terminer le joueur actif par position (tour impair = joueur 1, tour pair = joueur 2)
        const activePosition = (result.turnNumber % 2 === 1) ? 1 : 2;
        
        let isMyTurn = result.activePlayerId === activePlayerId;
        let whoCanAct = "";
        
        switch(result.currentPhase) {
            case 0:
                whoCanAct = isMyTurn ? "üü¢ C'EST TON TOUR (Placement)" : "üî¥ C'est le tour de l'adversaire";
                
                if (isMyTurn) {
                    FirstArgumentLabel.textContent = "Id carte jou√©";
                    SecondArgumentLabel.textContent = "Position de la carte jou√©";

                    FirstArgumentLabel.style = "display:block;"
                    SecondArgumentLabel.style = "display: block;"

                    FirstArgumentValue.value = 0;
                    SecondArgumentValue.value = 0;

                    btnSendAction.onclick = playCard;
                } else {
                    FirstArgumentLabel.style = "display:none;";
                    SecondArgumentLabel.style = "display: none;";
                    
                    btnSendAction.onclick = null;
                }
                break;
            case 1:
                whoCanAct = isMyTurn ? "üü¢ C'EST TON TOUR (Attaque)" : "üî¥ C'est le tour de l'adversaire";

                if (isMyTurn) {
                    FirstArgumentLabel.textContent = "Id card attack";

                    FirstArgumentLabel.style = "display: block;"
                    SecondArgumentLabel.style = "display: none;"

                    
                    FirstArgumentValue.value = 0;
                    SecondArgumentValue.value = 0;

                    btnSendAction.onclick = attackCard;
                } else {
                    FirstArgumentLabel.style = "display:none;";
                    SecondArgumentLabel.style = "display: none;";
                    
                    btnSendAction.onclick = null;
                }
                break;
            case 2:
                whoCanAct = isMyTurn ? "üü¢ C'EST TON TOUR (D√©fense)" : "üî¥ L'adversaire d√©fend";

                if (isMyTurn) {
                    FirstArgumentLabel.textContent = "Id card defend";
                    SecondArgumentLabel.textContent = "Id card attack";

                    FirstArgumentLabel.style = "display: block;"
                    SecondArgumentLabel.style = "display: block;"

                    
                    FirstArgumentValue.value = 0;
                    SecondArgumentValue.value = 0;

                    btnSendAction.onclick = defendCard;
                } else {
                    FirstArgumentLabel.style = "display:none;";
                    SecondArgumentLabel.style = "display: none;";
                    
                    btnSendAction.onclick = null;
                }
                break;
            case 3:
                whoCanAct = "‚è≥ Fin de tour...";
                FirstArgumentLabel.style = "display:none;";
                SecondArgumentLabel.style = "display: none;";
                
                btnSendAction.onclick = null;
                break;
        }
        
        activePlayerSpan.textContent = whoCanAct;
        
        // Changer la couleur de fond selon si c'est notre tour
        const phaseInfo = document.getElementById('phaseInfo');
        if (phaseInfo) {
            phaseInfo.style.background = isMyTurn ? '#d4edda' : '#f8d7da';
        }
    }
</script>
</body>
</html>